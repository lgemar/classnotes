Brainstorm for Midterm:

==> Problem 2 <==

@pre inputs @a first and @a last must define a valid iterator range such that
	@a last is reachable from @a first through the operator++
@pre @a map must define the operator() and always return integers in the range
	[0, num_buckets)
@post size return == num_buckets
@returns an array of iterators of type Iter with the property that 
	iterator found in bucket i iterates over the contents of that bucket

==> Problem 4 <==

-check_ is an array of indices that we have looked up and its length is equal
to the total number of lookups that we've made

-position_ is an array that has size 1 greater than the largest value we've
looked-up and the value at index i is the size of check when we looked up 
index i for the first time. This is also the index into value where the value
of index i can be found

-value_ stores the values in the array where the value of array[i] is stored
in value_[position[i]]

What do various conditions mean? 
Both these conditions simply check to see if we have referenced this 
position before
1.) position[i] >= check_.size() means that the index has never never been 
checked before because there is no entry of check that corresponds to the 
value at position[i]. It is unclear to me how the > condition could ever
be satisfied but the == condition could occur if the lookup index i happens 
to be the last new lookup into the array...ah, this just means that the value
in position[i] is garbage

2.) check_[position_[i]] != i means that the mapping between check_ and 
position_ has not been established and therefore the index has never been 
looked up before

Abstraction Function: 

V = { vi | value[position[i]] }

Representation Invariants: 

1.) For i in range [0, check_.size() ), check_[i] < position_.size() 
	==> We've never accessed an array index that is beyond our ability to map 
		that index back into a value 

2.) check_.size() == value_.size()
	==> check_ and value_ are extended in parallel and must remain the same size

3.) check_.size() <= position_.size() && value_.size() <= position_.size()
	==> There is no way that we could check more values than are in the array

