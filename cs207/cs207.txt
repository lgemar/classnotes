// The Graph has the responsibility of determining how to store points
// You can add / delete anything inside of the Graph class (for the pset)
class Graph {
	Node add_node(Point p);
	Note get_node(int i);

	Edge add_edge(Node a, Node b);
	Edge get_edge(int i);

	private:
		vector<Point> points_;
};

class Node {
	public:
		// The ampersand ensures that the point is returned by reference, not copy
		Point& position() {
			return g->points[uid];
		}
	private:
		Graph* g_; // 8 bytes
		int uid; // 4 bytes
		friend class Graph;
}

Graph g;

class Edge {
	Node a;
	Node b;
}

Back to binary search function....
We wanted to generalize the binary search for a type that contains a less than
operator.

template <class T>
// Adding "const" to v ensures that we will use v and definitely not change it
int bin_search(const T* a, int low, int high, const T& v)

Turns out that our "contract" is bordering on unreadable. It's getting too
complicated and we may want to work out a simpler way. Let's resummarize our 
approach to the binary search function.
	-> If v is contained in a, then we return first element not smaller than v.
	-> If v is not in a, then we return -1.
		-> Optionally: we could return the last mid.
		-> a[result] == v? If it's true, then v is in a.
			-> vi, low <= i < result, a[i] < v
			-> vi, result <= i < high, a[i] >= v

Let's write out the cleaner specification:
/** Find the first value in array that is not less than some value.
 * 
 * @tparam T is comparable: it supports the "less than" operator
 * @pre 0 <= low <= high <= size(a)
 * @pre for all i, j, low <= i < j < high, !(a[j] < a[i])
 * @returns The position of the first element not < v
 * @post for all i, low <= i <= result, a[i] < v
 * @post for all i, result <= i < high, !(a[i] < v)
**/
template <class T>
int lower_bound(const T* a, int low, int high, const T& v)
int bin_search(const T* a, int low, int high, const T& v) {
	int idx = lower_bound(...); 
	if (!(a[idx] < v) && !(v < a[idx]))
		return -1
	return idx;
}


9/8:
Review the contract from 9/5.
If the implementation obeys the contract, then the user should be happy no matter
the implementation. 

Invariants: (expls. preconditions and postconditions)
-> true statement at some point in the code
@pre
  -> true @ function entry
  -> contstrain the user to the inputs that we want
  -> if not satisfied we could...
	1. return error
	2. violate @posts
	3. How do we know that the conditions have not been satisfied?
		-> Assertions are checked invariants
		-> exple: assert( mid >= low && mid < high)
	4. Anything
		-> crash
@post
  -> True @ function exit
  -> Constrain the implementation
...I can change the implementation, but I CANT change the preconditions and 
postconditions...

@assertions are checked invariants...sometimes not always possible
  -> you can remove these at compile so they have no run-time overhead

Actual implementation:

int bin_search(const float* a, int low, int high, float v) 
{
	--high; 
	while(low <= high) 
	{
		int mid = low + (high - low) / 2; 
		if(v < a[mid]) // When the compiler sees this "less than" it searches for a operator<
			high = mid - 1; 
		else if (a[mid] < v)
			low = mid + 1;
		else
			return mid;
	}
	return -1;
}


Limitations to our algorithm: 
  1.) Entire array, no subranges (fixed)
  2.) only float
  3.) Only ascending order
  4.) Only searches arrays

Fix problem #2: 
	template <class T> //C++ Templates: allow us to use parametric (variable) polymorphism (forms)
	int bin_search(const T* a, int low, int high, T v)
Now I can define...
double* a_d = ... ;
bin_search(a_d, ... );
float* a_f = ... ;
bin_search(a_f, ... )

We can define our own types in C! Here is an example:
struct MyFloat {
	float v;
};

// This has a special meaning to the compiler...finds this as being a < operator
bool operator<(MyFloat a, MyFloat b) {
	return a v < b v;
}

(only difference between Struct and Class: Struct defaults to everything being public; 
class defaults to everything being private) 

What is a Type?
	-> representation
	-> Abstract value
	-> Operations
	-> Exple: MyFloat
		-> Representation: float
		-> Abstract value: float
		-> Operations: operation<, operation>

Now: My constraints are a bit complex. How can I simplify them?


9/5: 
Documentation: a contract between the user and the implementer

Binary search review: 
int bin_search(float* a, int n, float v) //no idea what this function is doing...

/** Binary search
  * Searches an array for a value using binary search.
  * @param[in] a The array to search
  * @param[in] low, high The range of @a a to search, [low, high)
  * @param[in] v The value to search for.
9/8-->  * @tparam type T is comparable: there exists a bool operator< (T, T) //We wrote this to only need one
  * returns An index into @a a or -1
  * 
  * @pre 0 <= @a low <= @a high <= size(@a a) -> abstract contractual agreement
  //* @pre @a for all i, j low <= i < j < high, a[i] <= a[j] (WHAT DOES THIS MEAN FOR TWO Ts)
9/8-->  * @pre @a for all i, j low <= i < j < high, !(a[j] < a[i])
  //* @returns idx such that either (a[idx] == v && low <= idx < high) or (NO IDEA WHAT == MEANS)
                 (idx == -1 && there does not exist i, low <= i < high, a[i] == v)
9/8-->  * @returns idx such that either (!(a[idx] < v) and !(a[idx] > v) && low <= idx < high) or
                 (idx == -1 && there does not exist i, low <= i < high, a[i] == v)
  * operates in O(log (high - low)) operations.

// the "const" promises that none of the values in memory will be changed
int bin_search(const float* a, int low, int high, float v);

Ways for improvement of binary search:
1.) Subranges -> low, high
2.) Only sorted arrays as of now
3.) Only floats as of now
