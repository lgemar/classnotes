9/22:
template

template <IT, Pred>
class filter_iterator {
	public:
		// typedef typename std::iterator_traits<IT>::value_type value_type;
		typedef typename IT::value_type value_type;

What type does filter iterator return? When I dereference, what type should I get? 
-->*IT

All iterators have...
--> a value_type: the type that I get when I dereference the iterator
--> a pointer_type: pointer to the type I get when I dereference
--> a reference_type
--> a difference_type
--> a iterator_tag: defines what type of iterator I am

All our filter iterator has to do is grab the value type of the iterator; see second
line in the class iterator, the one that is not commented out.

Adapter pattern: provide a uniform interface for two things that don't necessarily have 
the same interface. Now the filter_iterator can be used on top of any user-defined type
or just a simple pointer.

// define iterator traits
namespace std {
	template <IT>
	struct iterator_traits {
		using value_type = typename IT::value_type;	
		...
	}
}

// This is a template specialization; handle pointers the same way that we handle user define
// iterators
template<T>
struct iterator_traits<T*> {
	using value_type = T;
};

TYPE:
--> Representation
--> Abstract Values
--> Operations/Semantics

REPRESENTATION:
When we define Graph, we can have different representations that represent the same thing
class Graph {
	private:
		struct node_data {
			Point p_;
		}

		struct edge_data {
			Node n1_;
			Node n2_;
		}

		vector<node_data> nodes_;
		vector<edge_data> edges_;
};

class Node {
	private:
		Graph* g_;
		uid_type uid_;
};

ABSTRACT VALUE: something that MAPS our internal representation to abstract concepts/data
ABSTRACT FUNCTION: Obj Representation => Abstract Value
Abstractly, when we talk about a Graph, what do we define? 
Abstract value of graph: Set of nodes and edges
Graph = (Nodes, Edges)
N = [n0, n1, ..., nm]; m = node_.size() - 1;
Abstract value of a node: a position
Abstract function: ni = <g_->nodes_[uid_].p_, uid_>
Abstract value of an edge: its two nodes
E = {e0, e1, ..., ek}, k = edges_.size() - 1;
Abstract function (maps representation to its value):
ei = <g_->edges[uid_].n1_, ... >

Now there is something that's not documented...the RULES about our representation: 
--> What value can the representation take? We need representation invariants
	--> can edges_ be [(n0, n1), (n1, n0), (n1, n1)]?
		--> These representations don't fit abstract idea about what an edge is
		--> The graph is undirected and all edges must be distinct

REPRESENTATION INVARIANT: these are conditions on the representation in order for it to be valid
-> Maps an internal representation and its value to bool; these are RULES
-> Representation invariants are implied preconditions and postconditions to every member function!
-> Representation invariants can be broked between @pre and @post, in the middle of member funcs

Proposal: For all representations of the edges_ the uid_ of node1 is strictly less than uid_ of node2
More formally: for all i, edges_[i].n1.uid_ < edges_[i].n2.uid_
We can still have duplicates: vector<edge_data> edges_ => [(n0, n1), (n0, n1)]

Assignment: Read through HW1 and think about all the operations you need to perform

9/17:
// We decided that a pointer is a more powerful indicator of position than index
template <class T>
T* min(const std:vector<T>& a) {
	T* first = a.begin(); // 0 index
	T* end = a.end(); // index a.size()
	// Last is pointing to one past the end of the array, a[a.size()] is undefined
	if (first == last) return last;
	T* m = first;
	for (++first; first != last; ++first) {
		if (*first < *m)
			m = first;
	}
	return m;
}

The punch line!!
How can we deal with a subsequence? Pass in a first and a last.
What operations are we performing on out positions, T*? 
1. comparing (p == q)
2. assigning (p = q)
3. incremementing (++p)
4. dereference (*p)
----> These define the iterator concept

T*'s represent a position, so we should be able to handle the operations of 
position that are specified above. Let's replace the T*'s with IT, iterators.

/*
 * @pre [first, last) is a valid range of elements of type T
 * /
IT min(IT first, IT last) {
}

struct list_it {
	list_elem* curr;
	list_it& operator=(const list_it&)=default;
	bool operator==(const list_it& other) {
		return curr == other.curr;
	}
	list_it& operator++() {
		curr = curr->next_;
		return *this;
	}
	T& operator*() {
		return curr->val_;
	}
}

template <class T>
class list {
	struct list_elem {
		T val_;
		list_elem* head_;
	};
	list_elem* head_;
	unsigned size_;
	list_it begin() {
		return list_it(head_);
	}
	list_it end() {
		// Cannot increment or dereference the null pointer
		return list_it(nullptr);	
	}
}

Validity:
->[first, last) is a valid iterator range -> last is reachable by first
->last is iterator
->first may be invalid

// Let's work on a copy function -- this one can copy from an array to a list!! oh my!
template <class ItI, ItO>
ItO copy(ItI begin, ItI end, ItI, ItO out) {
	for(; begin!=end, ++begin,++out) {
		*out = *begin;
	}
}

struct counting_iterator {
	int n;
	operator==( ... ) {
		return n == other.n;
	}
	operator++() {
		++n;
	}
	operator*() {
		return n;
	}
}
9/15: 
NO BINARY SEARCH! 

/** Find the minimum element in a std::vector.
 * 
 **/

Should we return a T or an idx?
T -> Why? python, idx requires lookup
idx -> Gets T & position, handles 0 sized containers (return -1)

template <class T>
int min(const std::vector<T>& v) {
	if (v.size == 0) { 
		return -1;
	}
	T m = v[0];
	int mk = 0;
	for (int k = 1; k < v.size(); ++k) {
		if (v[k] < m) {
			m = v[k];
			mk = k;
		}
	}
	return mk;
}

I want my implementation to work on any kind of container!
template <class Container>
int min(const Container& v) {
	if (v.size == 0) { 
		return -1;
	}
	auto m = v[0];
	int mk = 0;
	// O(v.size()) for a vector and O(v.size()^2)
	for (int k = 1; k < v.size(); ++k) {
		if (v[k] < m) {
			m = v[k];
			mk = k;
		}
	}
	return mk;
}

Let's write a linked list quickly: 
template <class T>
class list {
	list_element* head;	
	class list_element {
		T val_;
		list_element* next_;
	}
	int size() const { 
		return size_;
	}
	// This indexing takes 0(i) time!!
	T& operator[](unsigned i) {
		list_element* current = head;
		for (; i != 0; --i)
			current = current->next;
		return current->val_;
	}
}

WE SHOULD BE ABLE TO DO THIS OPERATION IN ORDER N TIME!
We can't use subscripting operators anymore...

Write down some of our assumptions here:

-> Run through each position, denoted as k above
-> Compare positions (k < v.size())
-> Dereference a position (v[k])
-> Assignment of positions

... Big player here is a "position"...We need to abstract
on position...maybe a pointer?
template <class T>
T* min(const std::vector<T>& v) {
	T* first = v.begin();
	T* end = v.end(); // This should be one past the end
	if (first == end)
		return NULL;

	.... on Wed.
}


9/10:
// The Graph has the responsibility of determining how to store points
// You can add / delete anything inside of the Graph class (for the pset)
class Graph {
	Node add_node(Point p);
	Note get_node(int i);

	Edge add_edge(Node a, Node b);
	Edge get_edge(int i);

	private:
		vector<Point> points_;
};

class Node {
	public:
		// The ampersand ensures that the point is returned by reference, not copy
		Point& position() {
			return g->points[uid];
		}
	private:
		Graph* g_; // 8 bytes
		int uid; // 4 bytes
		friend class Graph;
}

Graph g;

class Edge {
	Node a;
	Node b;
}

Back to binary search function....
We wanted to generalize the binary search for a type that contains a less than
operator.

template <class T>
// Adding "const" to v ensures that we will use v and definitely not change it
int bin_search(const T* a, int low, int high, const T& v)

Turns out that our "contract" is bordering on unreadable. It's getting too
complicated and we may want to work out a simpler way. Let's resummarize our 
approach to the binary search function.
	-> If v is contained in a, then we return first element not smaller than v.
	-> If v is not in a, then we return -1.
		-> Optionally: we could return the last mid.
		-> a[result] == v? If it's true, then v is in a.
			-> vi, low <= i < result, a[i] < v
			-> vi, result <= i < high, a[i] >= v

Let's write out the cleaner specification:
/** Find the first value in array that is not less than some value.
 * 
 * @tparam T is comparable: it supports the "less than" operator
 * @pre 0 <= low <= high <= size(a)
 * @pre for all i, j, low <= i < j < high, !(a[j] < a[i])
 * @returns The position of the first element not < v
 * @post for all i, low <= i <= result, a[i] < v
 * @post for all i, result <= i < high, !(a[i] < v)
**/
template <class T>
int lower_bound(const T* a, int low, int high, const T& v)
int bin_search(const T* a, int low, int high, const T& v) {
	int idx = lower_bound(...); 
	if (!(a[idx] < v) && !(v < a[idx]))
		return -1
	return idx;
}


9/8:
Review the contract from 9/5.
If the implementation obeys the contract, then the user should be happy no matter
the implementation. 

Invariants: (expls. preconditions and postconditions)
-> true statement at some point in the code
@pre
  -> true @ function entry
  -> contstrain the user to the inputs that we want
  -> if not satisfied we could...
	1. return error
	2. violate @posts
	3. How do we know that the conditions have not been satisfied?
		-> Assertions are checked invariants
		-> exple: assert( mid >= low && mid < high)
	4. Anything
		-> crash
@post
  -> True @ function exit
  -> Constrain the implementation
...I can change the implementation, but I CANT change the preconditions and 
postconditions...

@assertions are checked invariants...sometimes not always possible
  -> you can remove these at compile so they have no run-time overhead

Actual implementation:

int bin_search(const float* a, int low, int high, float v) 
{
	--high; 
	while(low <= high) 
	{
		int mid = low + (high - low) / 2; 
		if(v < a[mid]) // When the compiler sees this "less than" it searches for a operator<
			high = mid - 1; 
		else if (a[mid] < v)
			low = mid + 1;
		else
			return mid;
	}
	return -1;
}


Limitations to our algorithm: 
  1.) Entire array, no subranges (fixed)
  2.) only float
  3.) Only ascending order
  4.) Only searches arrays

Fix problem #2: 
	template <class T> //C++ Templates: allow us to use parametric (variable) polymorphism (forms)
	int bin_search(const T* a, int low, int high, T v)
Now I can define...
double* a_d = ... ;
bin_search(a_d, ... );
float* a_f = ... ;
bin_search(a_f, ... )

We can define our own types in C! Here is an example:
struct MyFloat {
	float v;
};

// This has a special meaning to the compiler...finds this as being a < operator
bool operator<(MyFloat a, MyFloat b) {
	return a v < b v;
}

(only difference between Struct and Class: Struct defaults to everything being public; 
class defaults to everything being private) 

What is a Type?
	-> representation
	-> Abstract value
	-> Operations
	-> Exple: MyFloat
		-> Representation: float
		-> Abstract value: float
		-> Operations: operation<, operation>

Now: My constraints are a bit complex. How can I simplify them?


9/5: 
Documentation: a contract between the user and the implementer

Binary search review: 
int bin_search(float* a, int n, float v) //no idea what this function is doing...

/** Binary search
  * Searches an array for a value using binary search.
  * @param[in] a The array to search
  * @param[in] low, high The range of @a a to search, [low, high)
  * @param[in] v The value to search for.
9/8-->  * @tparam type T is comparable: there exists a bool operator< (T, T) //We wrote this to only need one
  * returns An index into @a a or -1
  * 
  * @pre 0 <= @a low <= @a high <= size(@a a) -> abstract contractual agreement
  //* @pre @a for all i, j low <= i < j < high, a[i] <= a[j] (WHAT DOES THIS MEAN FOR TWO Ts)
9/8-->  * @pre @a for all i, j low <= i < j < high, !(a[j] < a[i])
  //* @returns idx such that either (a[idx] == v && low <= idx < high) or (NO IDEA WHAT == MEANS)
                 (idx == -1 && there does not exist i, low <= i < high, a[i] == v)
9/8-->  * @returns idx such that either (!(a[idx] < v) and !(a[idx] > v) && low <= idx < high) or
                 (idx == -1 && there does not exist i, low <= i < high, a[i] == v)
  * operates in O(log (high - low)) operations.

// the "const" promises that none of the values in memory will be changed
int bin_search(const float* a, int low, int high, float v);

Ways for improvement of binary search:
1.) Subranges -> low, high
2.) Only sorted arrays as of now
3.) Only floats as of now
