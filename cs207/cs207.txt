10/1: 
??What is an ABSTRACTION FUNCTION??
==> An abstraction function is a mapping from the space of concrete values
	to the abstract space that the user is dealing with. 
==> I see the abstraction function as the function that takes a class as an 
	input and uses the data members and functions of the class to display to 
	the user the state of the class in readable form. 

??What is the ABSTRACTION FUNCTION for a POINT??
==> AF(Point) = <p.x, p.y, p.z>;
==> RI(Point) = True;
	==> There is no representation invariant that the point class is
		Trying to protect
	==> This drives Chris up the wall
	==> Because the representation invariant is always true there is 
		no reason for the data members to be private
	==> The class should keep track of the invariant for the user

??What is the class implementation??
class Point {
	public: 
		double x, y, z;
};

??What do you think about when you write a class??
==> What am I trying to represent with this class? What operations will I 
	provide to a user? 
==> How do I represent this class?
	==> And is that representation sufficient to represent the abstract values?
==> What are the representation invariants on the concrete representation? 
	==> If the invariants are non-trivial, then the concrete representation should
		be kept private and figure out how to defend them.
9/29: 
ROBUST SOFTWARE: In C++ it's possible to make programs that won't fail
Force = Mass * Acceleration
Energy = Mass * Velocity^2

We want to ensure that an expression like this, 
Mass = Mass * Acceleration, 
is impossible. One way we might be able to ensure that this is the case 
is if we use types. So let's define a type for all of our units: 

struct Mass {
	double v_;
};

struct Acceleration {
	double v_;
};

struct Force {
	double v_;
};

Force operator*(const Mass& m, const Acceleration& a) {
	return Force(m.v_ * a.v_);
}

Now if the user tries to write something like, 
Mass m2 = m1 * a; //WRONG

Now let's work on other operators: 
Mass * Mass
Force * Force
... this is getting to be a lot. 

Let's lighten the coding load on us! Here: 
[M * L / T^2] = [M] * [L / T^2];
[M * L^2 / T^2] = [M] * [L^2 / T^2];
we can define Mass, Length, Time as fundemental units:
unit = M^a * L^b * T^c;
unit = (a, b, c);

How can we implement something that checks our units? 
struct Unit {
	int a, b, c; // Type of the unit; this is runtime info
	double v_; // Value of the unit
};

// User can't check return type until run time
Unit operator*(const Unit& u1, const Unit& u2) {
}

The struct Unit is not great: 
1.) Unit must carry around 3 extra integers
2.) Unit holds run-time type information, and it will not ensure
	compile-time type checking

We want to have static, compile-time type information! If only there
was a way to parameterize types...TEMPLATES!

We want to parameterize our types on our units: 
template <int A, int B, int C>
struct Unit {
	double v_;
};

using Mass = Unit<1, 0, 0>;
using Force = Unit<1, 1, -2>;

Is it possible to define all the units at once? 
Now can we write operator* ? 

template<a1, b1, c1, a2, b2, c2>
Unit<a1 + b2, b1 + b2, c1 + c2> operator* (
		const Unit<a1, b1, c1>& u1, const Unit<a2, b2, c2>& u2) {
	return Unit<a1 + b2, b1 + b2, c1 + c2> (u1.v_ * u2.v_);
}

The compiler will figure out which units have been passed to the function
and determine all of the correct types.

??What is the overhead of writing this??
==> There is no overhead.

Unit becomes a type when we have specified template parameters. The type
is parameterized on the template parameters. At run time, two values are 
multiplied together. The storage overhead is zero. The compiler uses template
parameters to stamp out types and they are not used at all at run time. 
Types are generated at compile time and there is no storage or run-time 
overhead to using this system.

operator+(const Unit<A,B,C>& u1, const Unit<A,B,C>& u2);

BOOST C++: An example of template metaprogramming
==> Units
==> MPL / Fusion

Run time computation: 
double v = a * factorial(b);

What if I want to compute the factorial at compile time ? 
double v = a * factorial<4>::value;


9/26: 
Why are representation invariants useful? 
template <It, Pred>
filter_iterator {
	private:
		// Representation Invariant (RI): (it_==end_) || p(*it_)
		It it_, end_;
		Pred p_;
	/** This will allow us to keep the RI at beginning and END of funcs
	  * the RIs don't need to be true before this function
	  * Only PRIVATE member functions don't need to have the RIs as 
	  * @pres and @posts
	  */	
	void fix() {
		/** Advances it_ until RI 
		 * @post is that the RI is satisfied
		 */
		while (it_ != end_ && !p(*it)) {
			++it_; // when this returns, the RI MUST be true
		}
	}
};

Which functions could return without a valid invariant? 
--> ++ definitely could return unfixed so we need to call fix
--> The RI must be true after the CONSTRUCTOR as well

op==(const filter_iterator<It, Pred> other) {
	return (return it_ == other.it_) // not necessary: p_ == other.p_;
}

What are we trying to express with a filter iterator abstraction? 
--> position inside of a range such that it skips values that
	don't satisfy the predicate
--> When are two filter iterator's positions the same?
--> --> The positions of two filter iterator's must satisfy the pred.
--> --> When should the positions compare equal?
		return it_ == other.it_;

auto first = make_filtered(graph.node_begin(), graph.node_end(), 
							pred);
auto last = make_filtered(graph.node_end(), graph.node_end(), pred);
graph.add_nodes(first, last, node_map);

ADJACENCY LIST:
std::vector<std::vector<uid_type>> adj_;
0: 1, 3, 4
1: ....
2: 
3: 
.
.
.
n: 1, 3, 5, 7 ...

/** If any of these are not true there is a bug in our code */
AF(E) = E = { {ni, nj} | ni is in adjacency list of nj and vis versa }
RI adj_.size() == num_nodes(); // this is appear in add notes
if j is in adj_[i] then i must be in adj_[j] // apear in add edge

/** Must be powerful enough to return an edge */
EdgeIterator {
	inner_iterator it_;
	uid_type uid1;
	graph* g_;
}
AF: Represents a position to Edge(graph_, uid1, *it)
RI: it_ <= adj_[uid1].end() //Note: end == graph_.size();
--> g_ != nullptr
--> uid1 < g_-> adj_.size();
--> uid1 < *it_; // uid1 < uid2 b/c we have upper triangular matrix
--> --> the strength of these ^^ is written from weakest to strongest

/** How do we write a fix function? 
 * The @posts are the invariants! Crazy! 
 */
void fix() {
	assert(g != nullptr);
	while (uid1_ < g_->adj_.size()) {
		while (it_ < g_->adj_[uid1].end()) {
			if (uid1_ < *it)
				return;
			else
				++it_;
		}
		++uid1_; it_ = g_ (... little fuzzy about this...)
	}
}

/** RI for a node */
Node {
	Graph* g_;
	uid_type uid_;
}
RI: g_ != nullptr;
--> uid_ < g.num_nodes();

9/24: 

Think back to edge_data and nodes: 
struct edge_data {
Node n1_;
Node n2_;
};

Abstract functions (AF): 
AF(Graph) = (N, E) ((Nodes and Edges))
AF(N) = [n0, n1, ... , nm]; m = noes_.size()
ni = <g_->nodes_[i].p_, i>
AF(E) = {e0, e1, e2, ... , ek}
AF: E = { { e.n1, e.n2} | e is in e_ } 

Representation Invariants (RI):
k == e_.size(); for all i, e_[i].n1.uid < e_[i].n2.uid (Undirected self-edges)

How can we consolodate? Get rid of the pointers!
struct edge_data {
	uid_type uid1_;
	uid_type uid2_;
};

AF: E = { {g_->node(uid1), g_node(uid2)} | for all e in e_}
Simpler AF: E = { {ne.uid1_, ne.uid2_} | e in e_ }

Is this a bad representation for the operations you want to do? 
-> has_edge
-> add_edge
-> edge(i)
-> num_edges
-> iteration

Let's look at a Flat structure: 
-> has_edge: O(num_edges)
-> add_edge: O(num_edges)
-> edge(i) : O(1)
-> num_edges: O(1)
-> iteration: O(1)
-> incident: O(E)

Let's look at a Map structure: 
-> has_edge: O(log E) // E is num_edges
-> add_edge: O(log E)
-> edge(i): O(E)
-> num_edges: O(1)
-> iteration: O(1)
-> incident: O(E)

Let's look at a adjacency Matrix: 
	0	1	2	3
0	0	1	0	1
1	1	0	1	1
2	0	1	0	1
3	1	1	1	0

-> has_edge: O(1)
-> add_edge: O(1)
-> edge(i): O(N^2)
-> num_edges: O(1) / O(N^2)
-> iteration: O(N^2 / E)
-> incident: O(N)

Let's write out the represenation invariants for the Matrix: 
vector<vector<bool>> e_;
AF: E = { {ni, nj} | i < j && e[i][j] == true}
RI: e_.size == m, where m is the number of nodes; for all e_[i].size==m

Could also have written this out as a flat matrix: 
vector<bool> e2_;
e2_[m*i + j]

Try an adjacency list: 
0: 1,3
1: 0, 2, 3
2: 1,3
3: 0,1,2

Speed of an adjacency list: 
-> has_edge: O(d), O(log d) for sorted // bounded by largest degree of a node, usually small
-> add_edge: O(d), O(d) for sorted as well
-> edge(i): O(E), has to go through entire list to determine ith edge
-> num_edges: O(1), with a counter
-> iteration: O(1)
-> incident_edges: O(d)

9/22:
template

template <IT, Pred>
class filter_iterator {
	public:
		// typedef typename std::iterator_traits<IT>::value_type value_type;
		typedef typename IT::value_type value_type;

What type does filter iterator return? When I dereference, what type should I get? 
-->*IT

All iterators have...
--> a value_type: the type that I get when I dereference the iterator
--> a pointer_type: pointer to the type I get when I dereference
--> a reference_type
--> a difference_type
--> a iterator_tag: defines what type of iterator I am

All our filter iterator has to do is grab the value type of the iterator; see second
line in the class iterator, the one that is not commented out.

Adapter pattern: provide a uniform interface for two things that don't necessarily have 
the same interface. Now the filter_iterator can be used on top of any user-defined type
or just a simple pointer.

// define iterator traits
namespace std {
	template <IT>
	struct iterator_traits {
		using value_type = typename IT::value_type;	
		...
	}
}

// This is a template specialization; handle pointers the same way that we handle user define
// iterators
template<T>
struct iterator_traits<T*> {
	using value_type = T;
};

TYPE:
--> Representation
--> Abstract Values
--> Operations/Semantics

REPRESENTATION:
When we define Graph, we can have different representations that represent the same thing
class Graph {
	private:
		struct node_data {
			Point p_;
		}

		struct edge_data {
			Node n1_;
			Node n2_;
		}

		vector<node_data> nodes_;
		vector<edge_data> edges_;
};

class Node {
	private:
		Graph* g_;
		uid_type uid_;
};

ABSTRACT VALUE: something that MAPS our internal representation to abstract concepts/data
ABSTRACT FUNCTION: Obj Representation => Abstract Value
Abstractly, when we talk about a Graph, what do we define? 
Abstract value of graph: Set of nodes and edges
Graph = (Nodes, Edges)
N = [n0, n1, ..., nm]; m = node_.size() - 1;
Abstract value of a node: a position
Abstract function: ni = <g_->nodes_[uid_].p_, uid_>
Abstract value of an edge: its two nodes
E = {e0, e1, ..., ek}, k = edges_.size() - 1;
Abstract function (maps representation to its value):
ei = <g_->edges[uid_].n1_, ... >

Now there is something that's not documented...the RULES about our representation: 
--> What value can the representation take? We need representation invariants
	--> can edges_ be [(n0, n1), (n1, n0), (n1, n1)]?
		--> These representations don't fit abstract idea about what an edge is
		--> The graph is undirected and all edges must be distinct

REPRESENTATION INVARIANT: these are conditions on the representation in order for it to be valid
-> Maps an internal representation and its value to bool; these are RULES
-> Representation invariants are implied preconditions and postconditions to every member function!
-> Representation invariants can be broked between @pre and @post, in the middle of member funcs

Proposal: For all representations of the edges_ the uid_ of node1 is strictly less than uid_ of node2
More formally: for all i, edges_[i].n1.uid_ < edges_[i].n2.uid_
We can still have duplicates: vector<edge_data> edges_ => [(n0, n1), (n0, n1)]

Assignment: Read through HW1 and think about all the operations you need to perform

9/17:
// We decided that a pointer is a more powerful indicator of position than index
template <class T>
T* min(const std:vector<T>& a) {
	T* first = a.begin(); // 0 index
	T* end = a.end(); // index a.size()
	// Last is pointing to one past the end of the array, a[a.size()] is undefined
	if (first == last) return last;
	T* m = first;
	for (++first; first != last; ++first) {
		if (*first < *m)
			m = first;
	}
	return m;
}

The punch line!!
How can we deal with a subsequence? Pass in a first and a last.
What operations are we performing on out positions, T*? 
1. comparing (p == q)
2. assigning (p = q)
3. incremementing (++p)
4. dereference (*p)
----> These define the iterator concept

T*'s represent a position, so we should be able to handle the operations of 
position that are specified above. Let's replace the T*'s with IT, iterators.

/*
 * @pre [first, last) is a valid range of elements of type T
 * /
IT min(IT first, IT last) {
}

struct list_it {
	list_elem* curr;
	list_it& operator=(const list_it&)=default;
	bool operator==(const list_it& other) {
		return curr == other.curr;
	}
	list_it& operator++() {
		curr = curr->next_;
		return *this;
	}
	T& operator*() {
		return curr->val_;
	}
}

template <class T>
class list {
	struct list_elem {
		T val_;
		list_elem* head_;
	};
	list_elem* head_;
	unsigned size_;
	list_it begin() {
		return list_it(head_);
	}
	list_it end() {
		// Cannot increment or dereference the null pointer
		return list_it(nullptr);	
	}
}

Validity:
->[first, last) is a valid iterator range -> last is reachable by first
->last is iterator
->first may be invalid

// Let's work on a copy function -- this one can copy from an array to a list!! oh my!
template <class ItI, ItO>
ItO copy(ItI begin, ItI end, ItI, ItO out) {
	for(; begin!=end, ++begin,++out) {
		*out = *begin;
	}
}

struct counting_iterator {
	int n;
	operator==( ... ) {
		return n == other.n;
	}
	operator++() {
		++n;
	}
	operator*() {
		return n;
	}
}
9/15: 
NO BINARY SEARCH! 

/** Find the minimum element in a std::vector.
 * 
 **/

Should we return a T or an idx?
T -> Why? python, idx requires lookup
idx -> Gets T & position, handles 0 sized containers (return -1)

template <class T>
int min(const std::vector<T>& v) {
	if (v.size == 0) { 
		return -1;
	}
	T m = v[0];
	int mk = 0;
	for (int k = 1; k < v.size(); ++k) {
		if (v[k] < m) {
			m = v[k];
			mk = k;
		}
	}
	return mk;
}

I want my implementation to work on any kind of container!
template <class Container>
int min(const Container& v) {
	if (v.size == 0) { 
		return -1;
	}
	auto m = v[0];
	int mk = 0;
	// O(v.size()) for a vector and O(v.size()^2)
	for (int k = 1; k < v.size(); ++k) {
		if (v[k] < m) {
			m = v[k];
			mk = k;
		}
	}
	return mk;
}

Let's write a linked list quickly: 
template <class T>
class list {
	list_element* head;	
	class list_element {
		T val_;
		list_element* next_;
	}
	int size() const { 
		return size_;
	}
	// This indexing takes 0(i) time!!
	T& operator[](unsigned i) {
		list_element* current = head;
		for (; i != 0; --i)
			current = current->next;
		return current->val_;
	}
}

WE SHOULD BE ABLE TO DO THIS OPERATION IN ORDER N TIME!
We can't use subscripting operators anymore...

Write down some of our assumptions here:

-> Run through each position, denoted as k above
-> Compare positions (k < v.size())
-> Dereference a position (v[k])
-> Assignment of positions

... Big player here is a "position"...We need to abstract
on position...maybe a pointer?
template <class T>
T* min(const std::vector<T>& v) {
	T* first = v.begin();
	T* end = v.end(); // This should be one past the end
	if (first == end)
		return NULL;

	.... on Wed.
}


9/10:
// The Graph has the responsibility of determining how to store points
// You can add / delete anything inside of the Graph class (for the pset)
class Graph {
	Node add_node(Point p);
	Note get_node(int i);

	Edge add_edge(Node a, Node b);
	Edge get_edge(int i);

	private:
		vector<Point> points_;
};

class Node {
	public:
		// The ampersand ensures that the point is returned by reference, not copy
		Point& position() {
			return g->points[uid];
		}
	private:
		Graph* g_; // 8 bytes
		int uid; // 4 bytes
		friend class Graph;
}

Graph g;

class Edge {
	Node a;
	Node b;
}

Back to binary search function....
We wanted to generalize the binary search for a type that contains a less than
operator.

template <class T>
// Adding "const" to v ensures that we will use v and definitely not change it
int bin_search(const T* a, int low, int high, const T& v)

Turns out that our "contract" is bordering on unreadable. It's getting too
complicated and we may want to work out a simpler way. Let's resummarize our 
approach to the binary search function.
	-> If v is contained in a, then we return first element not smaller than v.
	-> If v is not in a, then we return -1.
		-> Optionally: we could return the last mid.
		-> a[result] == v? If it's true, then v is in a.
			-> vi, low <= i < result, a[i] < v
			-> vi, result <= i < high, a[i] >= v

Let's write out the cleaner specification:
/** Find the first value in array that is not less than some value.
 * 
 * @tparam T is comparable: it supports the "less than" operator
 * @pre 0 <= low <= high <= size(a)
 * @pre for all i, j, low <= i < j < high, !(a[j] < a[i])
 * @returns The position of the first element not < v
 * @post for all i, low <= i <= result, a[i] < v
 * @post for all i, result <= i < high, !(a[i] < v)
**/
template <class T>
int lower_bound(const T* a, int low, int high, const T& v)
int bin_search(const T* a, int low, int high, const T& v) {
	int idx = lower_bound(...); 
	if (!(a[idx] < v) && !(v < a[idx]))
		return -1
	return idx;
}


9/8:
Review the contract from 9/5.
If the implementation obeys the contract, then the user should be happy no matter
the implementation. 

Invariants: (expls. preconditions and postconditions)
-> true statement at some point in the code
@pre
  -> true @ function entry
  -> contstrain the user to the inputs that we want
  -> if not satisfied we could...
	1. return error
	2. violate @posts
	3. How do we know that the conditions have not been satisfied?
		-> Assertions are checked invariants
		-> exple: assert( mid >= low && mid < high)
	4. Anything
		-> crash
@post
  -> True @ function exit
  -> Constrain the implementation
...I can change the implementation, but I CANT change the preconditions and 
postconditions...

@assertions are checked invariants...sometimes not always possible
  -> you can remove these at compile so they have no run-time overhead

Actual implementation:

int bin_search(const float* a, int low, int high, float v) 
{
	--high; 
	while(low <= high) 
	{
		int mid = low + (high - low) / 2; 
		if(v < a[mid]) // When the compiler sees this "less than" it searches for a operator<
			high = mid - 1; 
		else if (a[mid] < v)
			low = mid + 1;
		else
			return mid;
	}
	return -1;
}


Limitations to our algorithm: 
  1.) Entire array, no subranges (fixed)
  2.) only float
  3.) Only ascending order
  4.) Only searches arrays

Fix problem #2: 
	template <class T> //C++ Templates: allow us to use parametric (variable) polymorphism (forms)
	int bin_search(const T* a, int low, int high, T v)
Now I can define...
double* a_d = ... ;
bin_search(a_d, ... );
float* a_f = ... ;
bin_search(a_f, ... )

We can define our own types in C! Here is an example:
struct MyFloat {
	float v;
};

// This has a special meaning to the compiler...finds this as being a < operator
bool operator<(MyFloat a, MyFloat b) {
	return a v < b v;
}

(only difference between Struct and Class: Struct defaults to everything being public; 
class defaults to everything being private) 

What is a Type?
	-> representation
	-> Abstract value
	-> Operations
	-> Exple: MyFloat
		-> Representation: float
		-> Abstract value: float
		-> Operations: operation<, operation>

Now: My constraints are a bit complex. How can I simplify them?


9/5: 
Documentation: a contract between the user and the implementer

Binary search review: 
int bin_search(float* a, int n, float v) //no idea what this function is doing...

/** Binary search
  * Searches an array for a value using binary search.
  * @param[in] a The array to search
  * @param[in] low, high The range of @a a to search, [low, high)
  * @param[in] v The value to search for.
9/8-->  * @tparam type T is comparable: there exists a bool operator< (T, T) //We wrote this to only need one
  * returns An index into @a a or -1
  * 
  * @pre 0 <= @a low <= @a high <= size(@a a) -> abstract contractual agreement
  //* @pre @a for all i, j low <= i < j < high, a[i] <= a[j] (WHAT DOES THIS MEAN FOR TWO Ts)
9/8-->  * @pre @a for all i, j low <= i < j < high, !(a[j] < a[i])
  //* @returns idx such that either (a[idx] == v && low <= idx < high) or (NO IDEA WHAT == MEANS)
                 (idx == -1 && there does not exist i, low <= i < high, a[i] == v)
9/8-->  * @returns idx such that either (!(a[idx] < v) and !(a[idx] > v) && low <= idx < high) or
                 (idx == -1 && there does not exist i, low <= i < high, a[i] == v)
  * operates in O(log (high - low)) operations.

// the "const" promises that none of the values in memory will be changed
int bin_search(const float* a, int low, int high, float v);

Ways for improvement of binary search:
1.) Subranges -> low, high
2.) Only sorted arrays as of now
3.) Only floats as of now
