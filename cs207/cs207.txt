11/3: 
==> Test review <==
==> Problem 1
	: Iterator concept is assumed to take constant time
==> Problem 2
	: OIter std::copy(IIter a, IIter b, OIter c)
	: offsets = [first, i1, i2, ..., last];
	: offsets should be referred to as result in the specification
	: @pre num_buckets > 0
	: @pre for all i, first <= i < last, 0 <= map(*i) < num_buckets;
	: @post for all i, new first <= i < j < new last, map(*i) <= map(*j)
	: @post result.size() == num_buckets + 1
	: @post for all i 0 <= i < num_buckets; for all it result[i] <= it < 
		result[i+1], map(*it) == i
==> Problem 4
	: { [v0, v1, ..., vi .. ] | vi = value_[position_[i]] ... IF 
		i <= position_.size() && position[i] < check_.size() 
		&& check_[position_[i]] == i
		ELSE vi = T()
	1.) RI( sv ) = check_.size() == value_.size()
	2.) for all i in range [0, check_.size()), 
		check_[i] < position_.size() && position_[check_[k]] == k
==> Problem 5
10/31:
==> <type_traits>
	template<class T, class U>
	struct is_same {
		constexpr static bool value = false;
	};
	if(is_same<int, float>::value) { ... }
	else if (is_same<int, int>::value { ... }

	template <class T>
	struct is_same<T, T> {
		constexpr static bool value = true;
	};
	struct true_type {
		constexpr static book value = true;
		typedef true_type type;
	};
	struct false_type {
		... 
	};
	template <class T, class U>
	struct is_same : public false_type {};
	template <class T>
	struct is_same : public true_type {};

	template<IIter, OIter>
	OIter copy(IIter first, IIter last, OIter out) {
		for( ; first != last; ++first, ++out)
			*out = *first;
	}
==> how would we copy in C? 
	memcpy(void* dest, void* src, size_t (last - first) * sizeof(T));
==> Using memcpy in copy?
	// This is only a shallow copy, not a deep copy
	template<T>
	T* copy (T* first, T* last, T* out) {
		memcpy(void* out, void* first, size_t (last - first) * sizeof(T));
	}
	: This would be a big problem for a vector<vector<int>>, copying
	  would simply create an alias
==> What is trivially copyable? Pretty much anything without a pointer
	: We would like to ask if T is trivially copyable
	template <T>
	T* copy(T* first, T* last, T*out) {
		if(is_trivially_copyable<T>::value)
			memcpy( ... );
		else
			for ; first != last; ++first, ++out)
				*out = *first;
	}
==> Here is a way that we can dispatch based on tags / types
	: We would like to call memcpy if T is trivially copyable
	template<T>
	T* copy(T* first, T* last, T* out) {
		return copy(first, last, out, is_trivially_copyable<T>());
	}
	T* copy( T* first, T* last, T* out, true_type) {
		memcpy( ... );
	}
	T* copy( T* first, T* last, T* out, false_type) {
		std::copy(first, last, out);
	}
==> Consider iterator tags
	: //Distance
	  size_t distance(Iter f, Iter l) {
	  	size_t n = 0;
		for( ; f != last; ++f, ++n);
		return n;
	  }
	: If we have a random access iterator...
  	size_t distance(Iter f, Iter l, input_iterator_tag) {
	  	size_t n = 0;
		for( ; f != last; ++f, ++n);
		return n;
	}
  	size_t distance(iter f, Iter l, random_access_iterator_tag) {
	  	return l - f;
	}
10/26:
==> LSP
	: pre -> weaker
	: post -> stronger
	: Could we make GraphSymmMatrix a derived class of Graph?
		--> remove nodes would remove rows from the matrix
		--> remove edges would modify elements of the symm matrix
		--> Would there be any issues?
			: GraphSymmMatrix
				--> op[]
				--> op(i,j)
				--> op*
				--> mult
			: size()
				--> Graph should return num_nodes
				--> GraphSymmMatrix should return num_nodes * num_nodes
==> Representation Invariants
	: RI(obj) maps the representation of the object to a boolean
	: class obj {
		public:
			int a;
		private:
			int b;
			vector<int> v;
	  };
	: RI(obj) : F(b, v) => {T/F}
		--> These are the preconditions and postconditions for every
			single public function
		--> What are the representation invariants of GraphSymmMatrix?
			: GraphSymmMatrix is an adapter that makes a graph look/feel
				like matrix
		--> RIs
			: preconditions to every public member function except constructors
				--> Something like...
					Edge e;
					e.g_ = this;
					e.uid1 = n_uid1;
					...should happen in a CONSTRUCTOR!
			: postconditions to every public member function except destructors
==> Abstraction Function
	: AF(obj) : F( "all member variables" ) => Abstract representation of data
	: Examples of abstract reps of data -> 
		- [a0, a1, ... , an-1]
		- {a0, a1, ... , an-1}
	: AF(Graph) : <N, E> that define a graph (N ordered array, E set of
						 unordered pairs of nodes)
				: N=[n0, n1, ... , nm-1], m = i2u_.size() (using rep to define
														   abstract values)
				: E={ {ni, nj} | i is in adj_[j] && j is in adj_[i] }
	: /** @breif A class representating a graph
	   * AF(GraphSymmMatrix) : F(graph) => num_nodes x num_nodes symmetric Matrix
										with elements Aij with i,j < num_nodes
										and Aij = {1, g_.node(i).value() == 'b'
													  && g_.node(j).value()=='b'
												  {0, g_.node(i).value() == 'b'
												  {Lij
	   */
	: AF(Point) : F(x, y, z) : a 3D point with position <x,y,z>

10/23:
??Inheritance??
==> Dynamic Polymorphism
	: class Base {
	  	void do() {};	
	  };
	  class Derived : public Base {
	  	void do() {};
	  };
	: Now we can use the base class's functionality for derived class, right?
	  size(Base& b)
	  draw(Base& b) {
	  	b.do(); // for non-virtual functionns the base class will be called
	  }
	: if we make the Base classes "do" function virtual, then the draw function
	  will call the derived class's "do" function (if the parameter is passed
	  by reference)
	: This changes between every language
	: Virtual function dispatches can be dangerous and slow down the program
	  considerably
		--> The compiler doesn't know at run time which virtual function it
			will call so it can't inline the virtual function
		--> The number of virtual functions inside MTL is 0. Generic interfaces
			are slow and not used in high performance computing.
	: Top Down
	  -Defining explicit interface
	  -Derived classes must implement
	: Bottom up
	  -Templates to define concepts
	  -Instantiated types must implement these functions
==> When do we need to use dynamic polymorphism?
	: In HW2 there were a static # and static type of Forces and constraints =>
	  tuple<Force1, Force2, ...>
	: When would we need dynamic polymorphism?
	: class Force {
	  	virtual Point eval(Node, double);
	  };
	  class GravityForce : public Force {
	  	eval(Node, double); 
	  };
	  class NodeSpringForce : public Force {
	  	eval(Node, double);
	  };
	: build a force collection
	  std::vector<Force*> forces;
	  Point eval(Node n, double t) {
	  	for(auto f : forces)
			f.p += f->eval(n, t);
	  }
	: What information has changed from the static to dynamic case?
		--> Dynamic # and Dynamic Types
	: Could we build a dynamic # of static types?
		==> vector<Force1>
			vector<Force2>
	: Could we build static # of dynamic types
		==> tuple<Force*, Force*, ... >
==> In what places can OOP and Dynamic polymorphism really be useful?
	==> STRATEGY PATTERN (related: VISITOR PATTERN)
		: choose implementation or algorithm at RUN-TIME
		: class SpecialMatrix {
		  	MatvecPlan* plan_;
			// Return new plan
			MatvecPlan* choose_plan( ... ) { ... }; 
		  };
==> Emphasis on the reading
	: What is base class BEHAVIOR?
	: pre -> weakened (the derived class can take a few extra or different
	  inputs)
	: post -> strengthened (all the postconditions of the base class must be
	  overridden and we are allowed to add more)
	: The result is that the invariants of the methods remains unchanged
	: Example, visual_iteration should not change the behavior of the cyclic
	  iteration, but it extends it
	
10/21: 
??OOP??
==> Programming Patterns
	--> Templates (Generic) [Concepts]
		: if it looks like a duck, walks like a duck, and quacks, it's
		  a duck
		: parameterizing functions based on types
		: scary, because documentation needs to be good when the 
		  function takes many template types
	--> Iterator
		: Filter
		: back_it
		: forward
		: random access
	--> Adaptor
		: Takes a type and wraps around it another type
		: filter_it and back_it are examples
	--> Proxy
==> Def'n: The ability to express intimate relationships between types 
	and classes
	--> Uses Inheritance
		: Polymorphism (dynamic, ?static?)
		: class B {
		  ...
		  };
		  class A : public B {
		  ...
		  };
		: A is a "derived class" and B is the "base class"
		: If you just want to use the function
		: class Engine
		  class Wheel
		  class Car
		  	: public Engine
			: public Wheel
		  class Plane
		  	: public Engine
			: public Wheel
		: Thumb test -> distinction between "is-a" and "has-a"
			--> inheritance gives a "is-a" relationship
			--> in the case above, the relationships are "has-a" 
				relationships
		: Better solution
		  class Car {
		  	Engine e_;
			Wheel w_;
		  };
		  class Plan {
		  	Engine e_;
			Wheel w_;
		  };
	--> What are the diffs between has-a and is-a relationships?
	--> Inheritance is very difficult when there are representation 
		invariants that need to be upheld
	--> Examples
		: class Shape {
			public: 
				Point center;
				void draw() { ... };
		  };
		  // Cube "is-a" shape
		  class Cube : public Shape {
		  	public:
				double volume() { return side * side * side };
				double side;	
				void draw() { ... };
		  };
		  class Sphere : public Shape {
		  	public: 
				double volume() {};
				double radius;
				void draw() { ... };
		  };
		: Functions
		  void draw(Shape& s) {
		  	s.draw();
		  }
		  void move(Shape& s) {
		  	s.center += 1;
		  }
		  double volume(Cube& c) {
		  	return c.volume();
		  }
		: Main 
		  main() {
		  	Shape sh;
			sh.draw() // Shape::draw()
			Cube c;
			c.draw() // Cube::draw()
			draw(c); // Which draw function gets called?
					 // Since it's a non-virtual override, 
					 	we will call Shape::draw()
					 // If you want to use Cube's draw, then
					 	you need the draw function to be 
						virtual
		  }
		: Using "Virtual"
		  class Shape {
			public: 
				Point center;
				virtual void draw() { ... };
		  };
		  class Cube : public Shape {
		  	public:
				double volume() { return side * side * side };
				double side;	
				virtual void draw() { ... };
		  };
10/15: 
??STL Containers: Data Representation??
==> Vector: an Array
==> Set + Map: Balanced Binary Tree
==> Unordered Set / Map: Hash Tables

Cont		Insert		Lookup:find Iterate
Vector		O(1), O(N)	O(N)		O(N)	
Set			O(log N)	O(log N)	O(N)
Unordered	O(1), O(N+) O(1)		O(N)

Cont		Insert	Lookup	Iterate
Vector		1x				1x			(very very fast, good caching)
Set			?x							(heap memory is not cache coherent)
Unordered	15x							

??When don't you want to use vectors??
==> If you are doing a ton of lookups, a set might make sense, especially
	an unordered set. The cost of a lookup is basically the hash cost, 
	plus the lookup, plus the compare.
==> Binary search on a vector means you need to keep the vector sorted
	and this can be very expensive. In this case you will want to use
	a hash table of some kind.
==> You may actually want to test which operation is the fastest for
	your particular application.

??What is Thouis's favorite spatial data structure??
==> A GRID! Subdivide space and keep a list of which grid each center 
	in 
	: To check for collisions just check inside 3x3 box
	: for b1 in balls
		for b2 in near(b1):
			if ( b1 < b2 ) && colliding: 
				do_something()
	: This grows linearly with the number of balls; each ball checks a 
	  constant number of objects around it
	: Improve the behavior of grid by keeping the balls Morton sorted 
	  in the grid

10/10:
??Can we apply constraints in faster than O(N) complexity??
==> Proposal: an entirely new data type, 
	class MortonSorted {
		MortonSorted(PointIter p_beg, PointIter p_end)

		// This is like a filter iterator, we could easily hit O(N)
		// We want to hit faster than O(N) dough
		neighborhood_iterator begin(BoundingBox& bb)
		neighborhood_iterator end(BoundingBox& bb)
	};
	==> How do I construct one of these using my graph?
		-Use a node iterator...ties this too closely to the graph class
	==> Transform Iterator? Build this with node iterators...?
		Grab a node iterator and change the dereference operator in order
		to return a Point and not a node
		// Transform iterator
		Point op*() {
			return (*it).position();
		}
		Free implementation: Boost iterator (takes iterator and what
		is known as a "projection" operator);
	==> How could we do this faster than O(N) to find points in 
		bounding box
	==> First, solve the problem in 2D
		: order the points along y and order the points along x
		: if the user passes a bounding box, do two lower bound 
		  searches to look for the lower bounds of the bounding
		  box in x and y, then iterate until you find upper bound
	==> Could guarantee the user that you are iterating over all points
		in the bounding box or only points in the bounding box. The 
		huge win here is that finding the lower bound is very fast.
==> What does Morton do? 
	Sorts points in 2D using a Z fractal pattern. The "code" that 
	imposes order on 2D space is a Morton code.
==> What does the Hilbert Curve look like? This is another space
	filling curve
	: advantages: a little bit smoother, better guarantee that two
	  close numbers in space are much closer in their Hilbert curve
	  encodings

10/8: 
??LOOP INVARIANTS??
Structure of a loop: 
// @pre
// @LI
while( P ) {
	S; 
	// @LI
}
// @post


/** You can write this inside of code ! */
1.) @pre => LI
2.) (LI + P) + S => LI
3.) LI + !P => @post (often most useful for figuring out LI)
4.) (LI + P) + S => DF(x) > DF(x + S) // DF defined over naturals
5.) (LI + (DF(x) == min)) => !P
6.) (LI + (DF(x) > min)) => (DF(x + s) >= min)

// Return pointer to first element not less than v
// @pre a is sorted, low <= high
int lower_bound(T* a, int low, int high, T v) {
	// @pre low <= high, a sorted
	// @LI: lo_orig <= i < lo, a[i] < v
		  : hi <= i < orig_hi => !(a[i] < v)
	while( low < high ) {
		int mid = low + (high - low) / 2;
		if( a[mid] < v)
			low = mid + 1;
		else 
			hi = mid;
		// @LI
	}
	// @post: For all i, low_orig <= i < low, a[i] < v
			: For low <= i < orig_hi, !(a[i] < v)
	return low;
}

??Questions on HW2??
==> Problem1Force has a lot of things going on. How do we write a single
	force function / struct that can encompass all of it? 
	==> Split it up into parts!
		==> Mass / Spring Force
		==> Gravity Force
	==> Interface for combining forces? 
		MassSpringForce msf();
		GravityForce gf();
		auto f = make_combined_force(gf, msf);
	==> How do we solve this problem? Abstract virtual function?
		class Force {
			virtual Point operator()(Node n, double t)=0;
		};

		class GravityForce : public Force {
			virtual Point operator()(Node n, double t) {
				// implementation
				return Point(0, 0, -grav * n.value().mass);
			}
		};
	==> So why does Chris not like this solution?
		There are strict rules about when and where to use inheritance.
		This solution is 35% slower than the solution that Chris
		developed. Virtual functions are implemented as pointers to 
		functions. Instead of being able to broadcast functions that
		can be inlined, there is a big list of pointers that point to 
		the implementation of the function in the concrete class.
		Why is this bad? This lookup happens in the innermost loop
		of the entire program. This is being done more times than 
		anything else so it becomes a very heavy cost. What can we do
		using C++ magic to make this better? 
	==> C++ magic to make this better?
		What is the force concept? anything(n, t) ==> Point
		// F1 and F2 must satisfy the force concept
		template <F1, F2>
		class MetaForce {
			F1 f1;
			F2 f2;
			Point operator()(Node n, double t) {
				return f1(n, t) + f2(n, t);
			}
		};
	==> What if we want to combine more than two forces? 
		as in: auto f2 make_combined_force(gf, msf, ZeroForce());
		==> The type of f2 could be:
			MF<MF<GF, MSF>, ZF>
		==> Are there any ways of checking that F1 and F2 in MetaForce
			obey the Force concept? No! This must be well documented
		==> Why is this faster? 
			Compiler knows the type of MetaForce at compile time.
			There is no function chasing and the compiler can inline 
			the functions. However, we have to specify all the forces
			at compile time. We may, however, generate forces at run
			time...Like, what if we want to change the number or type
			of forces at run time?

10/6: 
??LOOPS??
==> for( INITIAL; PREDICATE; NEXT ) {
		BODY;
	}

==> We could also write this as a WHILE loop: 
	==> F;
		while (P) {
			BODY;
			NEXT;
		}
==> Now we are going to assert @pre and loop
	invariants
	==> F;
		assert( @pre );
		assert( LI ); // Loop invariants
		while( Predicate ) {
			BODY;
			assert( LI );
		}
		assert( @post );
	==> 1.) @pre ==> LI; // Preconditions imply the loop 
		invariant
	==> 2.) P & S ==> LI
	==> 3.) (!P) & LI ==> @post
==> APPLY this to something simple (Think about this in terms of 
	mathematical induction)
	==> //@pre: n >= 0; @post:  result = Sum(0 to N)
		int sum( int n ) {
			int result = n;
			while( n > 0 ) { // @pre n >= 0, result == n
							 // LI: n >= 0; result == n_orig + (n_origin - 1) + n
				--n;
				result += n;
							 // LI: still holds here
			}
			return result;
		}
==> DECREMENTING FUNCTIONS (DF)
	==> 4.) P & LI ==> DF(x) > DF(x + S) // How does this apply with probability loops
	==> 5.) (DF(x) == min()) ==> !P
	==> ??What is a good decrementing function in our case??
		==> DF(x) = n, min of 0
	==> 6.) (P & LI) & S ==> DF(x) >= min
==> APPLY THIS TO GCD
		@pre a >= 1, b >= 1
		@post return GCD(a, b)
	==> int gcd(int a, int b) {
			@pre: a >= 1, b >= 1
			while( a != b ) {
				@LI: 
				if ( a > b )
					a -= b;
				else
					b -=a; 
				@LI: GDC(a, b) == GCD(orig_a, orig_b);
					 a >= 1, b >= 1
			@post: a == b; a == GCD(orig_a, orig_b);
			return a
			}
		}
	==> What the DF for this implementation?
		==> DF(x) = a + b - 2 * GCD; min 0
		==> DF(x) = max(a, b) - GCD; min 0
==> APPLY THIS TO LOWER BOUND
	==> int lower_bound( const T* a, int low, int high , T v) {
		}


10/3:
??Let's talk about GRAPH and REMOVE NODE / EDGE??
==> Excercise 2 served to remind us of invalid objects
	==> Erase function should invalidate the iterator it is operating on
	==> If you were to try to use that iterator the program has undefined
		behavior. 

==> Remove Node: concentrate on the specification for remove node
	==> If we invalidate any objects we NEED to know about that
	==> Can we write this without invalidating any iterators
	==> We still have to uphold this: g.node(i).index() == i;
		==> // Restrictions we've placed on graph
			g.add_node(p0); 
			g.add_node(p1);
			n0 = g.node(0);
			n1 = g.node(1); // uid_ == 1
			g.remove_node(n0);
			// n0.index() is undefined
			assert(n1.index() == 0); // true
			assert(n1.position() == p1); // true
			assert(n1 == g.node(0)); // uid_ == 1?
		==> Why can't we use a map??
			==> // Node implementation
				Node {
					Graph* g_;
					uid_type uid_;
				}
			==> // Adding to node_data in Graph
				// This allows for uid ==> index mapping
				Graph {
					node_data {
						Point p_;
						node_value_type v_;
						idx_type idx_;
					}

					// Indexed by a node uid_;
					vector<node_data> nodes_;
				}
		==> Do we need to go the other way: index ==> uid_ ?
			==> Yes: n1 == g.node(0);
			==> uid_ <==> index is what we need
		==> How can we map index ==> uid_?
			==> // Probably will require another data structure
				vector<uid_type> i2u_; // indexed by node index and returns uid_

==> Rewrite the Abstraction Function and the Invariants on Node
	==> AF(G) = <N, E>
		N = [n0, n1, ... , nm-1] m = i2u_.size();
		ni = <nodes_[i2u_[i]].p_, nodes_[i2u_[i]].v_, ... . idx_>
	==> AF(ni) = <graph_->nodes_[uid_].p_, ... (same as above ^^ ) >
	==> RI(G) = For all i in [0, i2u_.size), i == nodes_[i2u_[i]].idx_;
	==> We need to be able to tell from the uid_ whether a node is valid
		==> // Informal version
			RI(ni) = if uid_ is in graph_->i2u_, then node is valid
		==> // More formal
			RI(ni) = uid_ is in g_->i2u_; uid_ == g_->id2u_[g_->nodes_[uid_].idx_]
		==> What does this tell you about the rest of the implementation? 
			==> The above implies...
			==> uid_ < g_->nodes_.size() && uid_ >= 0;
			==> g_->nodes_[uid_].idx_ < g_->i2u_.size();
	==> Inside add_node and remove_node we need to satisfy the specified conditions
		==> remove_nodes will not modify node_.size()
		==> nodes_ is growing with the nodes we have added in our lifetime !!Problem!!
			==> If we didn't want node to grow unbounded...
			==> // Nice solution to this problem
				// Indexed by node index
				vector<node_data> nodes_;
				Node {
					Graph* g_;
					uid_type uid_; // What if we stored the index here? 
				}
				// Lookup values? Now u2i_ is growing without bound
				AF(ni) = <graph_->nodes_[g_->u2i_[uid_]].p_, ... >
/** */
remove_node( );

10/1: 
??What is an ABSTRACTION FUNCTION??
==> An abstraction function is a mapping from the space of concrete values
	to the abstract space that the user is dealing with. 
==> I see the abstraction function as the function that takes a class as an 
	input and uses the data members and functions of the class to display to 
	the user the state of the class in readable form. 

??What is the ABSTRACTION FUNCTION for a POINT??
==> AF(Point) = <p.x, p.y, p.z>;
==> RI(Point) = True;
	==> There is no representation invariant that the point class is
		Trying to protect
	==> This drives Chris up the wall
	==> Because the representation invariant is always true there is 
		no reason for the data members to be private
	==> The class should keep track of the invariant for the user

??What is the class implementation??
class Point {
	public: 
		double x, y, z;
};

??What do you think about when you write a class??
==> What am I trying to represent with this class? What operations will I 
	provide to a user? 
==> How do I represent this class?
	==> And is that representation sufficient to represent the abstract values?
==> What are the representation invariants on the concrete representation? 
	==> If the invariants are non-trivial, then the concrete representation should
		be kept private and figure out how to defend them.

??CREATING POWERFUL CONCEPTS??
When we start using iterators we can get some messy code: 

std::vector<int> v
for( auto it = v.begin(); it != v.end(); ++it); { // always use pre-increment
	auto& element = *it;
	.... ; // This is way too much boilerplate
}


??Pre-incremements and post-increments??
==> obj operator++() -> This is a pre-increment
	==> operator++() {
			++it; 
			return *this;
		}
==> obj operator++(int) -> This is a post-increment
	==> operator++(int) {
			obj copy = *this;
			++it;
			return copy;
		}
==> T* i = ... ;
	T* a = ++i; -> a is equal to the incremented i
	T* b = i++; -> b is equal to the original i

??Can we learn something from Python??
// We just want to iterate over all the elements
for (auto& elem : v) {
}

??RANGE??
The above code should work for any v that has a Range concept
==> RANGE
	==> iterator begin()
	==> iterator end()

??How can we improve on this for nodes and edges??
for (auto& n : graph) -> nodes?
for (auto& e : graph) -> edges?

class Graph {
	RangeEdge edges;
	// Does this stuff need to be inside of Graph? 
	struct RangeEdge {
		edge_it begin() {
			return Graph.edge_begin();
		}
		edge_it end();
	};
}
... We want to define ranges outside of a Graph

??What would be a nicer syntax: Use ADAPTER PATTERN??
==> We want to ADAPT a graph to be a range
==> Erik suggests that inside of Graph we could provide a Range
	type of edges and a Range type of Nodes
==> Here is a better syntax: 
	==> for (auto& n : nodes(graph));
	==> for (auto& e : edges(graph));

/** This function has one sole purpose: 
 * It's purpose is to change graph_.node_begin() and graph_.node_end()
 * 	to just be begin() and end() so that it follows the interface of the 
 *	Range
 */
NodeRange<Graph<v>> nodes(const Graph<v>& g) {
	return {g}; // shorthand constructor: {g} = NodeRange<Graph<v>> (g);
}

template<G>
struct NodeRange {
	const G& g_;
	node_iterator begin () {
		return g_.node_begin();
	}
	node_iterator end () {
		return g_.node_end();
	}
}

??What are the DESIGN PATTERNS that we have been using so far??
==> DESIGN PATTERNS
	==> Proxy -> small representation accesses actual values externally
	==> Iterator -> iterate over any kind of data structure
	==> Adapter / Concept -> specifying the concepts that types must specify
	==> Templates / Generic

??Think about propogating invariants??
min(Iter begin, Iter end), ... )
Anytime we write a function that takes a begin and end iterator...
@pre [begin, end) define a valid range -> This is a precondition
This is a design flaw. There is a push to change begin, end syntax to 
use exclusively Ranges. If a precondition is propogating throughout
all of your code then it is probably an invariant that should be 
upheld by a class. 


9/29: 
ROBUST SOFTWARE: In C++ it's possible to make programs that won't fail
Force = Mass * Acceleration
Energy = Mass * Velocity^2

We want to ensure that an expression like this, 
Mass = Mass * Acceleration, 
is impossible. One way we might be able to ensure that this is the case 
is if we use types. So let's define a type for all of our units: 

struct Mass {
	double v_;
};

struct Acceleration {
	double v_;
};

struct Force {
	double v_;
};

Force operator*(const Mass& m, const Acceleration& a) {
	return Force(m.v_ * a.v_);
}

Now if the user tries to write something like, 
Mass m2 = m1 * a; //WRONG

Now let's work on other operators: 
Mass * Mass
Force * Force
... this is getting to be a lot. 

Let's lighten the coding load on us! Here: 
[M * L / T^2] = [M] * [L / T^2];
[M * L^2 / T^2] = [M] * [L^2 / T^2];
we can define Mass, Length, Time as fundemental units:
unit = M^a * L^b * T^c;
unit = (a, b, c);

How can we implement something that checks our units? 
struct Unit {
	int a, b, c; // Type of the unit; this is runtime info
	double v_; // Value of the unit
};

// User can't check return type until run time
Unit operator*(const Unit& u1, const Unit& u2) {
}

The struct Unit is not great: 
1.) Unit must carry around 3 extra integers
2.) Unit holds run-time type information, and it will not ensure
	compile-time type checking

We want to have static, compile-time type information! If only there
was a way to parameterize types...TEMPLATES!

We want to parameterize our types on our units: 
template <int A, int B, int C>
struct Unit {
	double v_;
};

using Mass = Unit<1, 0, 0>;
using Force = Unit<1, 1, -2>;

Is it possible to define all the units at once? 
Now can we write operator* ? 

template<a1, b1, c1, a2, b2, c2>
Unit<a1 + b2, b1 + b2, c1 + c2> operator* (
		const Unit<a1, b1, c1>& u1, const Unit<a2, b2, c2>& u2) {
	return Unit<a1 + b2, b1 + b2, c1 + c2> (u1.v_ * u2.v_);
}

The compiler will figure out which units have been passed to the function
and determine all of the correct types.

??What is the overhead of writing this??
==> There is no overhead.

Unit becomes a type when we have specified template parameters. The type
is parameterized on the template parameters. At run time, two values are 
multiplied together. The storage overhead is zero. The compiler uses template
parameters to stamp out types and they are not used at all at run time. 
Types are generated at compile time and there is no storage or run-time 
overhead to using this system.

operator+(const Unit<A,B,C>& u1, const Unit<A,B,C>& u2);

BOOST C++: An example of template metaprogramming
==> Units
==> MPL / Fusion

Run time computation: 
double v = a * factorial(b);

What if I want to compute the factorial at compile time ? 
double v = a * factorial<4>::value;


9/26: 
Why are representation invariants useful? 
template <It, Pred>
filter_iterator {
	private:
		// Representation Invariant (RI): (it_==end_) || p(*it_)
		It it_, end_;
		Pred p_;
	/** This will allow us to keep the RI at beginning and END of funcs
	  * the RIs don't need to be true before this function
	  * Only PRIVATE member functions don't need to have the RIs as 
	  * @pres and @posts
	  */	
	void fix() {
		/** Advances it_ until RI 
		 * @post is that the RI is satisfied
		 */
		while (it_ != end_ && !p(*it)) {
			++it_; // when this returns, the RI MUST be true
		}
	}
};

Which functions could return without a valid invariant? 
--> ++ definitely could return unfixed so we need to call fix
--> The RI must be true after the CONSTRUCTOR as well

op==(const filter_iterator<It, Pred> other) {
	return (return it_ == other.it_) // not necessary: p_ == other.p_;
}

What are we trying to express with a filter iterator abstraction? 
--> position inside of a range such that it skips values that
	don't satisfy the predicate
--> When are two filter iterator's positions the same?
--> --> The positions of two filter iterator's must satisfy the pred.
--> --> When should the positions compare equal?
		return it_ == other.it_;

auto first = make_filtered(graph.node_begin(), graph.node_end(), 
							pred);
auto last = make_filtered(graph.node_end(), graph.node_end(), pred);
graph.add_nodes(first, last, node_map);

ADJACENCY LIST:
std::vector<std::vector<uid_type>> adj_;
0: 1, 3, 4
1: ....
2: 
3: 
.
.
.
n: 1, 3, 5, 7 ...

/** If any of these are not true there is a bug in our code */
AF(E) = E = { {ni, nj} | ni is in adjacency list of nj and vis versa }
RI adj_.size() == num_nodes(); // this is appear in add notes
if j is in adj_[i] then i must be in adj_[j] // apear in add edge

/** Must be powerful enough to return an edge */
EdgeIterator {
	inner_iterator it_;
	uid_type uid1;
	graph* g_;
}
AF: Represents a position to Edge(graph_, uid1, *it)
RI: it_ <= adj_[uid1].end() //Note: end == graph_.size();
--> g_ != nullptr
--> uid1 < g_-> adj_.size();
--> uid1 < *it_; // uid1 < uid2 b/c we have upper triangular matrix
--> --> the strength of these ^^ is written from weakest to strongest

/** How do we write a fix function? 
 * The @posts are the invariants! Crazy! 
 */
void fix() {
	assert(g != nullptr);
	while (uid1_ < g_->adj_.size()) {
		while (it_ < g_->adj_[uid1].end()) {
			if (uid1_ < *it)
				return;
			else
				++it_;
		}
		++uid1_; it_ = g_ (... little fuzzy about this...)
	}
}

/** RI for a node */
Node {
	Graph* g_;
	uid_type uid_;
}
RI: g_ != nullptr;
--> uid_ < g.num_nodes();

9/24: 

Think back to edge_data and nodes: 
struct edge_data {
Node n1_;
Node n2_;
};

Abstract functions (AF): 
AF(Graph) = (N, E) ((Nodes and Edges))
AF(N) = [n0, n1, ... , nm]; m = noes_.size()
ni = <g_->nodes_[i].p_, i>
AF(E) = {e0, e1, e2, ... , ek}
AF: E = { { e.n1, e.n2} | e is in e_ } 

Representation Invariants (RI):
k == e_.size(); for all i, e_[i].n1.uid < e_[i].n2.uid (Undirected self-edges)

How can we consolodate? Get rid of the pointers!
struct edge_data {
	uid_type uid1_;
	uid_type uid2_;
};

AF: E = { {g_->node(uid1), g_node(uid2)} | for all e in e_}
Simpler AF: E = { {ne.uid1_, ne.uid2_} | e in e_ }

Is this a bad representation for the operations you want to do? 
-> has_edge
-> add_edge
-> edge(i)
-> num_edges
-> iteration

Let's look at a Flat structure: 
-> has_edge: O(num_edges)
-> add_edge: O(num_edges)
-> edge(i) : O(1)
-> num_edges: O(1)
-> iteration: O(1)
-> incident: O(E)

Let's look at a Map structure: 
-> has_edge: O(log E) // E is num_edges
-> add_edge: O(log E)
-> edge(i): O(E)
-> num_edges: O(1)
-> iteration: O(1)
-> incident: O(E)

Let's look at a adjacency Matrix: 
	0	1	2	3
0	0	1	0	1
1	1	0	1	1
2	0	1	0	1
3	1	1	1	0

-> has_edge: O(1)
-> add_edge: O(1)
-> edge(i): O(N^2)
-> num_edges: O(1) / O(N^2)
-> iteration: O(N^2 / E)
-> incident: O(N)

Let's write out the represenation invariants for the Matrix: 
vector<vector<bool>> e_;
AF: E = { {ni, nj} | i < j && e[i][j] == true}
RI: e_.size == m, where m is the number of nodes; for all e_[i].size==m

Could also have written this out as a flat matrix: 
vector<bool> e2_;
e2_[m*i + j]

Try an adjacency list: 
0: 1,3
1: 0, 2, 3
2: 1,3
3: 0,1,2

Speed of an adjacency list: 
-> has_edge: O(d), O(log d) for sorted // bounded by largest degree of a node, usually small
-> add_edge: O(d), O(d) for sorted as well
-> edge(i): O(E), has to go through entire list to determine ith edge
-> num_edges: O(1), with a counter
-> iteration: O(1)
-> incident_edges: O(d)

9/22:
template

template <IT, Pred>
class filter_iterator {
	public:
		// typedef typename std::iterator_traits<IT>::value_type value_type;
		typedef typename IT::value_type value_type;

What type does filter iterator return? When I dereference, what type should I get? 
-->*IT

All iterators have...
--> a value_type: the type that I get when I dereference the iterator
--> a pointer_type: pointer to the type I get when I dereference
--> a reference_type
--> a difference_type
--> a iterator_tag: defines what type of iterator I am

All our filter iterator has to do is grab the value type of the iterator; see second
line in the class iterator, the one that is not commented out.

Adapter pattern: provide a uniform interface for two things that don't necessarily have 
the same interface. Now the filter_iterator can be used on top of any user-defined type
or just a simple pointer.

// define iterator traits
namespace std {
	template <IT>
	struct iterator_traits {
		using value_type = typename IT::value_type;	
		...
	}
}

// This is a template specialization; handle pointers the same way that we handle user define
// iterators
template<T>
struct iterator_traits<T*> {
	using value_type = T;
};

TYPE:
--> Representation
--> Abstract Values
--> Operations/Semantics

REPRESENTATION:
When we define Graph, we can have different representations that represent the same thing
class Graph {
	private:
		struct node_data {
			Point p_;
		}

		struct edge_data {
			Node n1_;
			Node n2_;
		}

		vector<node_data> nodes_;
		vector<edge_data> edges_;
};

class Node {
	private:
		Graph* g_;
		uid_type uid_;
};

ABSTRACT VALUE: something that MAPS our internal representation to abstract concepts/data
ABSTRACT FUNCTION: Obj Representation => Abstract Value
Abstractly, when we talk about a Graph, what do we define? 
Abstract value of graph: Set of nodes and edges
Graph = (Nodes, Edges)
N = [n0, n1, ..., nm]; m = node_.size() - 1;
Abstract value of a node: a position
Abstract function: ni = <g_->nodes_[uid_].p_, uid_>
Abstract value of an edge: its two nodes
E = {e0, e1, ..., ek}, k = edges_.size() - 1;
Abstract function (maps representation to its value):
ei = <g_->edges[uid_].n1_, ... >

Now there is something that's not documented...the RULES about our representation: 
--> What value can the representation take? We need representation invariants
	--> can edges_ be [(n0, n1), (n1, n0), (n1, n1)]?
		--> These representations don't fit abstract idea about what an edge is
		--> The graph is undirected and all edges must be distinct

REPRESENTATION INVARIANT: these are conditions on the representation in order for it to be valid
-> Maps an internal representation and its value to bool; these are RULES
-> Representation invariants are implied preconditions and postconditions to every member function!
-> Representation invariants can be broked between @pre and @post, in the middle of member funcs

Proposal: For all representations of the edges_ the uid_ of node1 is strictly less than uid_ of node2
More formally: for all i, edges_[i].n1.uid_ < edges_[i].n2.uid_
We can still have duplicates: vector<edge_data> edges_ => [(n0, n1), (n0, n1)]

Assignment: Read through HW1 and think about all the operations you need to perform

9/17:
// We decided that a pointer is a more powerful indicator of position than index
template <class T>
T* min(const std:vector<T>& a) {
	T* first = a.begin(); // 0 index
	T* end = a.end(); // index a.size()
	// Last is pointing to one past the end of the array, a[a.size()] is undefined
	if (first == last) return last;
	T* m = first;
	for (++first; first != last; ++first) {
		if (*first < *m)
			m = first;
	}
	return m;
}

The punch line!!
How can we deal with a subsequence? Pass in a first and a last.
What operations are we performing on out positions, T*? 
1. comparing (p == q)
2. assigning (p = q)
3. incremementing (++p)
4. dereference (*p)
----> These define the iterator concept

T*'s represent a position, so we should be able to handle the operations of 
position that are specified above. Let's replace the T*'s with IT, iterators.

/*
 * @pre [first, last) is a valid range of elements of type T
 * /
IT min(IT first, IT last) {
}

struct list_it {
	list_elem* curr;
	list_it& operator=(const list_it&)=default;
	bool operator==(const list_it& other) {
		return curr == other.curr;
	}
	list_it& operator++() {
		curr = curr->next_;
		return *this;
	}
	T& operator*() {
		return curr->val_;
	}
}

template <class T>
class list {
	struct list_elem {
		T val_;
		list_elem* head_;
	};
	list_elem* head_;
	unsigned size_;
	list_it begin() {
		return list_it(head_);
	}
	list_it end() {
		// Cannot increment or dereference the null pointer
		return list_it(nullptr);	
	}
}

Validity:
->[first, last) is a valid iterator range -> last is reachable by first
->last is iterator
->first may be invalid

// Let's work on a copy function -- this one can copy from an array to a list!! oh my!
template <class ItI, ItO>
ItO copy(ItI begin, ItI end, ItI, ItO out) {
	for(; begin!=end, ++begin,++out) {
		*out = *begin;
	}
}

struct counting_iterator {
	int n;
	operator==( ... ) {
		return n == other.n;
	}
	operator++() {
		++n;
	}
	operator*() {
		return n;
	}
}
9/15: 
NO BINARY SEARCH! 

/** Find the minimum element in a std::vector.
 * 
 **/

Should we return a T or an idx?
T -> Why? python, idx requires lookup
idx -> Gets T & position, handles 0 sized containers (return -1)

template <class T>
int min(const std::vector<T>& v) {
	if (v.size == 0) { 
		return -1;
	}
	T m = v[0];
	int mk = 0;
	for (int k = 1; k < v.size(); ++k) {
		if (v[k] < m) {
			m = v[k];
			mk = k;
		}
	}
	return mk;
}

I want my implementation to work on any kind of container!
template <class Container>
int min(const Container& v) {
	if (v.size == 0) { 
		return -1;
	}
	auto m = v[0];
	int mk = 0;
	// O(v.size()) for a vector and O(v.size()^2)
	for (int k = 1; k < v.size(); ++k) {
		if (v[k] < m) {
			m = v[k];
			mk = k;
		}
	}
	return mk;
}

Let's write a linked list quickly: 
template <class T>
class list {
	list_element* head;	
	class list_element {
		T val_;
		list_element* next_;
	}
	int size() const { 
		return size_;
	}
	// This indexing takes 0(i) time!!
	T& operator[](unsigned i) {
		list_element* current = head;
		for (; i != 0; --i)
			current = current->next;
		return current->val_;
	}
}

WE SHOULD BE ABLE TO DO THIS OPERATION IN ORDER N TIME!
We can't use subscripting operators anymore...

Write down some of our assumptions here:

-> Run through each position, denoted as k above
-> Compare positions (k < v.size())
-> Dereference a position (v[k])
-> Assignment of positions

... Big player here is a "position"...We need to abstract
on position...maybe a pointer?
template <class T>
T* min(const std::vector<T>& v) {
	T* first = v.begin();
	T* end = v.end(); // This should be one past the end
	if (first == end)
		return NULL;

	.... on Wed.
}


9/10:
// The Graph has the responsibility of determining how to store points
// You can add / delete anything inside of the Graph class (for the pset)
class Graph {
	Node add_node(Point p);
	Note get_node(int i);

	Edge add_edge(Node a, Node b);
	Edge get_edge(int i);

	private:
		vector<Point> points_;
};

class Node {
	public:
		// The ampersand ensures that the point is returned by reference, not copy
		Point& position() {
			return g->points[uid];
		}
	private:
		Graph* g_; // 8 bytes
		int uid; // 4 bytes
		friend class Graph;
}

Graph g;

class Edge {
	Node a;
	Node b;
}

Back to binary search function....
We wanted to generalize the binary search for a type that contains a less than
operator.

template <class T>
// Adding "const" to v ensures that we will use v and definitely not change it
int bin_search(const T* a, int low, int high, const T& v)

Turns out that our "contract" is bordering on unreadable. It's getting too
complicated and we may want to work out a simpler way. Let's resummarize our 
approach to the binary search function.
	-> If v is contained in a, then we return first element not smaller than v.
	-> If v is not in a, then we return -1.
		-> Optionally: we could return the last mid.
		-> a[result] == v? If it's true, then v is in a.
			-> vi, low <= i < result, a[i] < v
			-> vi, result <= i < high, a[i] >= v

Let's write out the cleaner specification:
/** Find the first value in array that is not less than some value.
 * 
 * @tparam T is comparable: it supports the "less than" operator
 * @pre 0 <= low <= high <= size(a)
 * @pre for all i, j, low <= i < j < high, !(a[j] < a[i])
 * @returns The position of the first element not < v
 * @post for all i, low <= i <= result, a[i] < v
 * @post for all i, result <= i < high, !(a[i] < v)
**/
template <class T>
int lower_bound(const T* a, int low, int high, const T& v)
int bin_search(const T* a, int low, int high, const T& v) {
	int idx = lower_bound(...); 
	if (!(a[idx] < v) && !(v < a[idx]))
		return -1
	return idx;
}


9/8:
Review the contract from 9/5.
If the implementation obeys the contract, then the user should be happy no matter
the implementation. 

Invariants: (expls. preconditions and postconditions)
-> true statement at some point in the code
@pre
  -> true @ function entry
  -> contstrain the user to the inputs that we want
  -> if not satisfied we could...
	1. return error
	2. violate @posts
	3. How do we know that the conditions have not been satisfied?
		-> Assertions are checked invariants
		-> exple: assert( mid >= low && mid < high)
	4. Anything
		-> crash
@post
  -> True @ function exit
  -> Constrain the implementation
...I can change the implementation, but I CANT change the preconditions and 
postconditions...

@assertions are checked invariants...sometimes not always possible
  -> you can remove these at compile so they have no run-time overhead

Actual implementation:

int bin_search(const float* a, int low, int high, float v) 
{
	--high; 
	while(low <= high) 
	{
		int mid = low + (high - low) / 2; 
		if(v < a[mid]) // When the compiler sees this "less than" it searches for a operator<
			high = mid - 1; 
		else if (a[mid] < v)
			low = mid + 1;
		else
			return mid;
	}
	return -1;
}


Limitations to our algorithm: 
  1.) Entire array, no subranges (fixed)
  2.) only float
  3.) Only ascending order
  4.) Only searches arrays

Fix problem #2: 
	template <class T> //C++ Templates: allow us to use parametric (variable) polymorphism (forms)
	int bin_search(const T* a, int low, int high, T v)
Now I can define...
double* a_d = ... ;
bin_search(a_d, ... );
float* a_f = ... ;
bin_search(a_f, ... )

We can define our own types in C! Here is an example:
struct MyFloat {
	float v;
};

// This has a special meaning to the compiler...finds this as being a < operator
bool operator<(MyFloat a, MyFloat b) {
	return a v < b v;
}

(only difference between Struct and Class: Struct defaults to everything being public; 
class defaults to everything being private) 

What is a Type?
	-> representation
	-> Abstract value
	-> Operations
	-> Exple: MyFloat
		-> Representation: float
		-> Abstract value: float
		-> Operations: operation<, operation>

Now: My constraints are a bit complex. How can I simplify them?


9/5: 
Documentation: a contract between the user and the implementer

Binary search review: 
int bin_search(float* a, int n, float v) //no idea what this function is doing...

/** Binary search
  * Searches an array for a value using binary search.
  * @param[in] a The array to search
  * @param[in] low, high The range of @a a to search, [low, high)
  * @param[in] v The value to search for.
9/8-->  * @tparam type T is comparable: there exists a bool operator< (T, T) //We wrote this to only need one
  * returns An index into @a a or -1
  * 
  * @pre 0 <= @a low <= @a high <= size(@a a) -> abstract contractual agreement
  //* @pre @a for all i, j low <= i < j < high, a[i] <= a[j] (WHAT DOES THIS MEAN FOR TWO Ts)
9/8-->  * @pre @a for all i, j low <= i < j < high, !(a[j] < a[i])
  //* @returns idx such that either (a[idx] == v && low <= idx < high) or (NO IDEA WHAT == MEANS)
                 (idx == -1 && there does not exist i, low <= i < high, a[i] == v)
9/8-->  * @returns idx such that either (!(a[idx] < v) and !(a[idx] > v) && low <= idx < high) or
                 (idx == -1 && there does not exist i, low <= i < high, a[i] == v)
  * operates in O(log (high - low)) operations.

// the "const" promises that none of the values in memory will be changed
int bin_search(const float* a, int low, int high, float v);

Ways for improvement of binary search:
1.) Subranges -> low, high
2.) Only sorted arrays as of now
3.) Only floats as of now
